# Lab 1: Binary Semaphores 
### คำถามสำหรับการทดลоง
1. เมื่อ give semaphore หลายครั้งติดต่อกัน จะเกิดอะไรขึ้น?
- Binary Semaphore มีสถานะได้เพียง 2 แบบเท่านั้นคือ
     - 0 → ไม่มี (Empty)
     - 1 → พร้อมใช้งาน (Available)
- เมื่อเรียกใช้ xSemaphoreGive() หลายครั้งติดต่อกันโดยยังไม่มี Task ไหน Take ไป
     - ค่า Semaphore จะ ไม่เกิน 1
     - ดังนั้น การ Give ซ้ำ ๆ จะไม่มีผลเพิ่มเติมหลังจากครั้งแรก —
     - Semaphore จะคงค่าอยู่ที่ 1 จนกว่าจะถูก Take
2. ISR สามารถใช้ `xSemaphoreGive` หรือต้องใช้ `xSemaphoreGiveFromISR`?
- ใน Interrupt Service Routine (ISR) ต้องใช้
```
xSemaphoreGiveFromISR();
```
แทน xSemaphoreGive()
- เหตุผลคือ xSemaphoreGiveFromISR() ถูกออกแบบมาให้ ปลอดภัยสำหรับการใช้งานใน Interrupt Context
โดยจะ ไม่สลับ Task ทันที แต่จะตั้งค่าธงให้ Scheduler ไปจัดการหลังจาก ISR จบ
ส่วน xSemaphoreGive() ใช้ได้เฉพาะใน Task Context เท่านั้น
3. Binary Semaphore แตกต่างจาก Queue อย่างไร?
  - วัตถุประสงค์การใช้งานต่างกัน
    - Binary Semaphore ใช้สำหรับ “การซิงโครไนซ์เหตุการณ์” เช่น บอกว่าเหตุการณ์หนึ่งเกิดขึ้นแล้ว
    - Queue ใช้สำหรับ “การส่งข้อมูล” ระหว่าง task หนึ่งไปยังอีก task หนึ่ง
  - ลักษณะของข้อมูลที่เก็บต่างกัน
    - Binary Semaphore ไม่มีข้อมูลในตัว มีเพียงสถานะ 0 หรือ 1
    - Queue มีช่องเก็บข้อมูลจริง สามารถบรรจุข้อมูลหลายชิ้นตามขนาดที่กำหนดได้
  - จำนวนค่าที่เก็บได้ต่างกัน
    - Binary Semaphore เก็บได้แค่ 1 ครั้ง (ให้แล้วต้องถูก take ก่อนถึงจะให้ใหม่ได้)
    - Queue สามารถเก็บได้หลายรายการแบบคิว FIFO (มาก่อนได้ก่อน)
  - ลักษณะการใช้งานต่างกัน
    - Binary Semaphore ใช้เพื่อแจ้งเหตุการณ์ เช่น ISR ให้สัญญาณให้ task ทำงานต่อ
    - Queue ใช้เพื่อส่งค่าหรือข้อมูลจริง เช่น ส่งค่าเซนเซอร์หรือข้อความระหว่าง task
  - แนวคิดพื้นฐานต่างกัน
    - Binary Semaphore = “สัญญาณ”
    - Queue = “กล่องใส่ข้อมูล”
